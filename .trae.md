# å›ºä½“åºŸç‰©é¢†åŸŸAgentæ¡†æ¶è®¾è®¡æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

**é¡¹ç›®åç§°**: SolidWaste-Agent (SWAgent)

**é¡¹ç›®å®šä½**: é¢å‘å›ºä½“åºŸç‰©é¢†åŸŸçš„å¤šæ™ºèƒ½ä½“åä½œæ¡†æ¶ï¼Œæ”¯æŒç§‘ç ”è¾…åŠ©ã€ä»£ç ç”Ÿæˆã€æŠ¥å‘Šæ’°å†™ã€æ•°æ®åˆ†æç­‰ä»»åŠ¡ã€‚

**æ ¸å¿ƒç‰¹æ€§**:
- ğŸ”„ çµæ´»çš„Agentäº¤äº’ä¸é€šä¿¡æœºåˆ¶
- ğŸ“ ä¸Šä¸‹æ–‡æ„ŸçŸ¥ä¸è®°å¿†ç®¡ç†
- ğŸ› ï¸ å¯æ‰©å±•çš„å·¥å…·è°ƒç”¨ç³»ç»Ÿ
- ğŸ­ å›ºåºŸé¢†åŸŸä¸“ä¸šçŸ¥è¯†é›†æˆ

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
solidwaste-agent/
â”‚
â”œâ”€â”€ ğŸ“„ README.md                     # é¡¹ç›®è¯´æ˜æ–‡æ¡£
â”œâ”€â”€ ğŸ“„ requirements.txt              # ä¾èµ–åŒ…åˆ—è¡¨
â”œâ”€â”€ ğŸ“„ setup.py                      # å®‰è£…é…ç½®
â”œâ”€â”€ ğŸ“„ config.yaml                   # å…¨å±€é…ç½®æ–‡ä»¶
â”‚
â”œâ”€â”€ ğŸ“‚ swagent/                      # æ ¸å¿ƒåŒ…
â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“‚ core/                     # æ ¸å¿ƒæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ base_agent.py         # AgentåŸºç±»
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ message.py            # æ¶ˆæ¯å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ context.py            # ä¸Šä¸‹æ–‡ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ memory.py             # è®°å¿†ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ communication.py      # é€šä¿¡åè®®
â”‚   â”‚   â””â”€â”€ ğŸ“„ orchestrator.py       # ç¼–æ’è°ƒåº¦å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“‚ agents/                   # Agentå®ç°
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ planner_agent.py      # è§„åˆ’Agent
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ coder_agent.py        # ä»£ç Agent
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ writer_agent.py       # å†™ä½œAgent
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ researcher_agent.py   # ç ”ç©¶Agent
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ data_agent.py         # æ•°æ®åˆ†æAgent
â”‚   â”‚   â””â”€â”€ ğŸ“„ reviewer_agent.py     # å®¡æ ¸Agent
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“‚ tools/                    # å·¥å…·ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ base_tool.py          # å·¥å…·åŸºç±»
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tool_registry.py      # å·¥å…·æ³¨å†Œä¸­å¿ƒ
â”‚   â”‚   â”œâ”€â”€ ğŸ“‚ builtin/              # å†…ç½®å·¥å…·
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ code_executor.py  # ä»£ç æ‰§è¡Œå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ file_handler.py   # æ–‡ä»¶å¤„ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ web_search.py     # ç½‘ç»œæœç´¢
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ calculator.py     # è®¡ç®—å·¥å…·
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ visualizer.py     # å¯è§†åŒ–å·¥å…·
â”‚   â”‚   â””â”€â”€ ğŸ“‚ domain/               # é¢†åŸŸå·¥å…·
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ waste_classifier.py    # åºŸç‰©åˆ†ç±»
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ emission_calculator.py # æ’æ”¾è®¡ç®—
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ lca_analyzer.py        # ç”Ÿå‘½å‘¨æœŸè¯„ä¼°
â”‚   â”‚       â””â”€â”€ ğŸ“„ policy_checker.py      # æ”¿ç­–åˆè§„æ£€æŸ¥
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“‚ domain/                   # å›ºåºŸé¢†åŸŸæ¨¡å—
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ knowledge_base.py     # é¢†åŸŸçŸ¥è¯†åº“
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ terminology.py        # ä¸“ä¸šæœ¯è¯­
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ standards.py          # è¡Œä¸šæ ‡å‡†
â”‚   â”‚   â””â”€â”€ ğŸ“‚ data/                 # é¢†åŸŸæ•°æ®
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ waste_categories.json
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ treatment_methods.json
â”‚   â”‚       â””â”€â”€ ğŸ“„ emission_factors.json
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“‚ llm/                      # LLMæ¥å£å±‚
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ base_llm.py           # LLMåŸºç±»
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ openai_client.py      # OpenAIæ¥å£
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ local_llm.py          # æœ¬åœ°æ¨¡å‹æ¥å£
â”‚   â”‚   â””â”€â”€ ğŸ“„ prompt_manager.py     # Promptç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“‚ prompts/                  # Promptæ¨¡æ¿
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ system_prompts.py     # ç³»ç»Ÿæç¤ºè¯
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ task_prompts.py       # ä»»åŠ¡æç¤ºè¯
â”‚   â”‚   â””â”€â”€ ğŸ“‚ templates/            # æ¨¡æ¿æ–‡ä»¶
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ planner.txt
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ coder.txt
â”‚   â”‚       â”œâ”€â”€ ğŸ“„ writer.txt
â”‚   â”‚       â””â”€â”€ ğŸ“„ reviewer.txt
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ“‚ utils/                    # å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ ğŸ“„ __init__.py
â”‚       â”œâ”€â”€ ğŸ“„ logger.py             # æ—¥å¿—ç³»ç»Ÿ
â”‚       â”œâ”€â”€ ğŸ“„ config.py             # é…ç½®ç®¡ç†
â”‚       â””â”€â”€ ğŸ“„ helpers.py            # è¾…åŠ©å‡½æ•°
â”‚
â”œâ”€â”€ ğŸ“‚ workflows/                    # å·¥ä½œæµå®šä¹‰
â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”œâ”€â”€ ğŸ“„ base_workflow.py          # å·¥ä½œæµåŸºç±»
â”‚   â”œâ”€â”€ ğŸ“„ research_workflow.py      # ç§‘ç ”å·¥ä½œæµ
â”‚   â”œâ”€â”€ ğŸ“„ report_workflow.py        # æŠ¥å‘Šå·¥ä½œæµ
â”‚   â””â”€â”€ ğŸ“„ analysis_workflow.py      # åˆ†æå·¥ä½œæµ
â”‚
â”œâ”€â”€ ğŸ“‚ examples/                     # ç¤ºä¾‹ä»£ç 
â”‚   â”œâ”€â”€ ğŸ“„ 01_simple_chat.py         # ç®€å•å¯¹è¯
â”‚   â”œâ”€â”€ ğŸ“„ 02_code_generation.py     # ä»£ç ç”Ÿæˆ
â”‚   â”œâ”€â”€ ğŸ“„ 03_report_writing.py      # æŠ¥å‘Šæ’°å†™
â”‚   â”œâ”€â”€ ğŸ“„ 04_multi_agent.py         # å¤šAgentåä½œ
â”‚   â””â”€â”€ ğŸ“„ 05_domain_analysis.py     # é¢†åŸŸåˆ†æ
â”‚
â”œâ”€â”€ ğŸ“‚ tests/                        # æµ‹è¯•ä»£ç 
â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”œâ”€â”€ ğŸ“„ test_agents.py
â”‚   â”œâ”€â”€ ğŸ“„ test_tools.py
â”‚   â”œâ”€â”€ ğŸ“„ test_communication.py
â”‚   â””â”€â”€ ğŸ“„ test_workflows.py
â”‚
â””â”€â”€ ğŸ“‚ docs/                         # æ–‡æ¡£
    â”œâ”€â”€ ğŸ“„ architecture.md           # æ¶æ„è®¾è®¡
    â”œâ”€â”€ ğŸ“„ api_reference.md          # APIå‚è€ƒ
    â”œâ”€â”€ ğŸ“„ development_guide.md      # å¼€å‘æŒ‡å—
    â””â”€â”€ ğŸ“„ domain_knowledge.md       # é¢†åŸŸçŸ¥è¯†è¯´æ˜
```

---

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„è®¾è®¡

### 1. AgentåŸºç±» (`core/base_agent.py`)

```python
"""
AgentåŸºç±»å®šä¹‰
æ‰€æœ‰ä¸“ä¸šAgentéƒ½ç»§æ‰¿è‡ªæ­¤ç±»
"""
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
import uuid
from datetime import datetime


class AgentState(Enum):
    """AgentçŠ¶æ€æšä¸¾"""
    IDLE = "idle"           # ç©ºé—²
    THINKING = "thinking"   # æ€è€ƒä¸­
    EXECUTING = "executing" # æ‰§è¡Œä¸­
    WAITING = "waiting"     # ç­‰å¾…ä¸­
    ERROR = "error"         # é”™è¯¯
    FINISHED = "finished"   # å®Œæˆ


@dataclass
class AgentConfig:
    """Agenté…ç½®"""
    name: str
    role: str
    description: str
    model: str = "gpt-4"
    temperature: float = 0.7
    max_tokens: int = 4096
    tools: List[str] = field(default_factory=list)
    system_prompt: str = ""


class BaseAgent(ABC):
    """
    AgentåŸºç±»
  
    èŒè´£:
    - å®šä¹‰Agentçš„åŸºæœ¬å±æ€§å’Œè¡Œä¸º
    - ç®¡ç†AgentçŠ¶æ€
    - æä¾›æ¶ˆæ¯å¤„ç†æ¥å£
    """
  
    def __init__(self, config: AgentConfig):
        self.id = str(uuid.uuid4())
        self.config = config
        self.state = AgentState.IDLE
        self.memory = []  # çŸ­æœŸè®°å¿†
        self.context = {}  # ä¸Šä¸‹æ–‡
        self.created_at = datetime.now()
      
    @property
    def name(self) -> str:
        return self.config.name
  
    @property
    def role(self) -> str:
        return self.config.role
  
    @abstractmethod
    async def think(self, input_message: 'Message') -> 'ThinkResult':
        """
        æ€è€ƒè¿‡ç¨‹ - åˆ†æè¾“å…¥ï¼Œå†³å®šè¡ŒåŠ¨
      
        Args:
            input_message: è¾“å…¥æ¶ˆæ¯
          
        Returns:
            ThinkResult: æ€è€ƒç»“æœï¼ŒåŒ…å«è¡ŒåŠ¨è®¡åˆ’
        """
        pass
  
    @abstractmethod
    async def act(self, think_result: 'ThinkResult') -> 'ActionResult':
        """
        æ‰§è¡Œè¡ŒåŠ¨
      
        Args:
            think_result: æ€è€ƒç»“æœ
          
        Returns:
            ActionResult: è¡ŒåŠ¨ç»“æœ
        """
        pass
  
    async def run(self, input_message: 'Message') -> 'Message':
        """
        Agentä¸»è¿è¡Œå¾ªç¯
      
        Args:
            input_message: è¾“å…¥æ¶ˆæ¯
          
        Returns:
            Message: è¾“å‡ºæ¶ˆæ¯
        """
        self.state = AgentState.THINKING
      
        try:
            # 1. æ€è€ƒé˜¶æ®µ
            think_result = await self.think(input_message)
          
            # 2. æ‰§è¡Œé˜¶æ®µ
            self.state = AgentState.EXECUTING
            action_result = await self.act(think_result)
          
            # 3. æ›´æ–°è®°å¿†
            self._update_memory(input_message, action_result)
          
            # 4. æ„é€ è¾“å‡ºæ¶ˆæ¯
            output_message = self._create_output_message(action_result)
          
            self.state = AgentState.FINISHED
            return output_message
          
        except Exception as e:
            self.state = AgentState.ERROR
            raise AgentExecutionError(f"Agent {self.name} execution failed: {e}")
  
    def _update_memory(self, input_msg: 'Message', result: 'ActionResult'):
        """æ›´æ–°çŸ­æœŸè®°å¿†"""
        self.memory.append({
            "timestamp": datetime.now(),
            "input": input_msg.content,
            "output": result.content,
            "metadata": result.metadata
        })
        # ä¿æŒè®°å¿†çª—å£å¤§å°
        if len(self.memory) > 20:
            self.memory = self.memory[-20:]
  
    def _create_output_message(self, result: 'ActionResult') -> 'Message':
        """åˆ›å»ºè¾“å‡ºæ¶ˆæ¯"""
        return Message(
            sender=self.id,
            sender_name=self.name,
            content=result.content,
            msg_type=MessageType.RESPONSE,
            metadata=result.metadata
        )
  
    def get_state_info(self) -> Dict[str, Any]:
        """è·å–AgentçŠ¶æ€ä¿¡æ¯"""
        return {
            "id": self.id,
            "name": self.name,
            "role": self.role,
            "state": self.state.value,
            "memory_size": len(self.memory),
            "context_keys": list(self.context.keys())
        }


class AgentExecutionError(Exception):
    """Agentæ‰§è¡Œå¼‚å¸¸"""
    pass
```

### 2. æ¶ˆæ¯å®šä¹‰ (`core/message.py`)

```python
"""
æ¶ˆæ¯ç³»ç»Ÿå®šä¹‰
ç”¨äºAgentä¹‹é—´çš„é€šä¿¡
"""
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from enum import Enum
from datetime import datetime
import uuid
import json


class MessageType(Enum):
    """æ¶ˆæ¯ç±»å‹"""
    # åŸºç¡€ç±»å‹
    REQUEST = "request"         # è¯·æ±‚
    RESPONSE = "response"       # å“åº”
  
    # ä»»åŠ¡ç±»å‹
    TASK = "task"               # ä»»åŠ¡åˆ†é…
    TASK_RESULT = "task_result" # ä»»åŠ¡ç»“æœ
  
    # åä½œç±»å‹
    QUERY = "query"             # æŸ¥è¯¢
    INFORM = "inform"           # é€šçŸ¥
    CONFIRM = "confirm"         # ç¡®è®¤
    REJECT = "reject"           # æ‹’ç»
  
    # ç³»ç»Ÿç±»å‹
    SYSTEM = "system"           # ç³»ç»Ÿæ¶ˆæ¯
    ERROR = "error"             # é”™è¯¯æ¶ˆæ¯
    HEARTBEAT = "heartbeat"     # å¿ƒè·³


class ContentType(Enum):
    """å†…å®¹ç±»å‹"""
    TEXT = "text"               # çº¯æ–‡æœ¬
    CODE = "code"               # ä»£ç 
    JSON = "json"               # JSONæ•°æ®
    MARKDOWN = "markdown"       # Markdown
    FILE = "file"               # æ–‡ä»¶å¼•ç”¨
    IMAGE = "image"             # å›¾ç‰‡
    TABLE = "table"             # è¡¨æ ¼æ•°æ®


@dataclass
class MessageContent:
    """æ¶ˆæ¯å†…å®¹"""
    type: ContentType
    data: Any
    language: Optional[str] = None  # ä»£ç è¯­è¨€
    filename: Optional[str] = None  # æ–‡ä»¶å
  
    def to_dict(self) -> Dict:
        return {
            "type": self.type.value,
            "data": self.data,
            "language": self.language,
            "filename": self.filename
        }


@dataclass
class Message:
    """
    æ¶ˆæ¯ç±»
  
    Agentä¹‹é—´é€šä¿¡çš„åŸºæœ¬å•å…ƒ
    """
    sender: str                          # å‘é€è€…ID
    content: str                         # æ¶ˆæ¯å†…å®¹
    msg_type: MessageType = MessageType.REQUEST
    sender_name: str = ""                # å‘é€è€…åç§°
    receiver: Optional[str] = None       # æ¥æ”¶è€…ID (Noneè¡¨ç¤ºå¹¿æ’­)
    receiver_name: Optional[str] = None  # æ¥æ”¶è€…åç§°
  
    # å…ƒæ•°æ®
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    parent_id: Optional[str] = None      # çˆ¶æ¶ˆæ¯ID (ç”¨äºè¿½è¸ªå¯¹è¯)
    thread_id: Optional[str] = None      # çº¿ç¨‹ID (ç”¨äºåˆ†ç»„)
  
    # æ‰©å±•å†…å®¹
    attachments: List[MessageContent] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
  
    # ä¼˜å…ˆçº§å’Œæ ‡ç­¾
    priority: int = 0                    # ä¼˜å…ˆçº§ (0æœ€ä½)
    tags: List[str] = field(default_factory=list)
  
    def to_dict(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            "id": self.id,
            "sender": self.sender,
            "sender_name": self.sender_name,
            "receiver": self.receiver,
            "receiver_name": self.receiver_name,
            "content": self.content,
            "msg_type": self.msg_type.value,
            "timestamp": self.timestamp.isoformat(),
            "parent_id": self.parent_id,
            "thread_id": self.thread_id,
            "attachments": [a.to_dict() for a in self.attachments],
            "metadata": self.metadata,
            "priority": self.priority,
            "tags": self.tags
        }
  
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Message':
        """ä»å­—å…¸åˆ›å»º"""
        data['msg_type'] = MessageType(data['msg_type'])
        data['timestamp'] = datetime.fromisoformat(data['timestamp'])
        data['attachments'] = [
            MessageContent(
                type=ContentType(a['type']),
                data=a['data'],
                language=a.get('language'),
                filename=a.get('filename')
            ) for a in data.get('attachments', [])
        ]
        return cls(**data)
  
    def to_json(self) -> str:
        """è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²"""
        return json.dumps(self.to_dict(), ensure_ascii=False, indent=2)
  
    def reply(self, content: str, msg_type: MessageType = MessageType.RESPONSE) -> 'Message':
        """åˆ›å»ºå›å¤æ¶ˆæ¯"""
        return Message(
            sender=self.receiver or "",
            sender_name=self.receiver_name or "",
            receiver=self.sender,
            receiver_name=self.sender_name,
            content=content,
            msg_type=msg_type,
            parent_id=self.id,
            thread_id=self.thread_id or self.id
        )


@dataclass
class ThinkResult:
    """æ€è€ƒç»“æœ"""
    action: str                          # è¦æ‰§è¡Œçš„åŠ¨ä½œ
    reasoning: str                       # æ¨ç†è¿‡ç¨‹
    plan: List[str] = field(default_factory=list)  # æ‰§è¡Œè®¡åˆ’
    tools_needed: List[str] = field(default_factory=list)  # éœ€è¦çš„å·¥å…·
    confidence: float = 0.0              # ç½®ä¿¡åº¦
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ActionResult:
    """è¡ŒåŠ¨ç»“æœ"""
    success: bool                        # æ˜¯å¦æˆåŠŸ
    content: str                         # ç»“æœå†…å®¹
    artifacts: List[MessageContent] = field(default_factory=list)  # äº§å‡ºç‰©
    metadata: Dict[str, Any] = field(default_factory=dict)
    error: Optional[str] = None          # é”™è¯¯ä¿¡æ¯
```

### 3. ä¸Šä¸‹æ–‡ç®¡ç† (`core/context.py`)

```python
"""
ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ
ç®¡ç†Agentæ‰§è¡Œè¿‡ç¨‹ä¸­çš„ä¸Šä¸‹æ–‡ä¿¡æ¯
"""
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from datetime import datetime
from enum import Enum
import threading
import copy


class ContextScope(Enum):
    """ä¸Šä¸‹æ–‡ä½œç”¨åŸŸ"""
    GLOBAL = "global"           # å…¨å±€ä¸Šä¸‹æ–‡
    SESSION = "session"         # ä¼šè¯ä¸Šä¸‹æ–‡
    TASK = "task"               # ä»»åŠ¡ä¸Šä¸‹æ–‡
    AGENT = "agent"             # Agentç§æœ‰ä¸Šä¸‹æ–‡


@dataclass
class ContextItem:
    """ä¸Šä¸‹æ–‡é¡¹"""
    key: str
    value: Any
    scope: ContextScope
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    ttl: Optional[int] = None   # ç”Ÿå­˜æ—¶é—´(ç§’), Noneè¡¨ç¤ºæ°¸ä¹…
    metadata: Dict[str, Any] = field(default_factory=dict)


class ContextManager:
    """
    ä¸Šä¸‹æ–‡ç®¡ç†å™¨
  
    èŒè´£:
    - ç®¡ç†ä¸åŒä½œç”¨åŸŸçš„ä¸Šä¸‹æ–‡
    - æä¾›ä¸Šä¸‹æ–‡çš„è¯»å†™æ¥å£
    - æ”¯æŒä¸Šä¸‹æ–‡ç»§æ‰¿å’Œéš”ç¦»
    """
  
    def __init__(self):
        self._contexts: Dict[str, Dict[str, ContextItem]] = {
            ContextScope.GLOBAL.value: {},
            ContextScope.SESSION.value: {},
            ContextScope.TASK.value: {},
            ContextScope.AGENT.value: {}
        }
        self._lock = threading.RLock()
  
    def set(self, key: str, value: Any, 
            scope: ContextScope = ContextScope.SESSION,
            ttl: Optional[int] = None,
            metadata: Optional[Dict] = None) -> None:
        """
        è®¾ç½®ä¸Šä¸‹æ–‡å€¼
      
        Args:
            key: é”®å
            value: å€¼
            scope: ä½œç”¨åŸŸ
            ttl: ç”Ÿå­˜æ—¶é—´
            metadata: å…ƒæ•°æ®
        """
        with self._lock:
            now = datetime.now()
            if key in self._contexts[scope.value]:
                # æ›´æ–°ç°æœ‰é¡¹
                item = self._contexts[scope.value][key]
                item.value = value
                item.updated_at = now
                if ttl is not None:
                    item.ttl = ttl
                if metadata:
                    item.metadata.update(metadata)
            else:
                # åˆ›å»ºæ–°é¡¹
                self._contexts[scope.value][key] = ContextItem(
                    key=key,
                    value=value,
                    scope=scope,
                    created_at=now,
                    updated_at=now,
                    ttl=ttl,
                    metadata=metadata or {}
                )
  
    def get(self, key: str, default: Any = None,
            scope: Optional[ContextScope] = None) -> Any:
        """
        è·å–ä¸Šä¸‹æ–‡å€¼
      
        å¦‚æœä¸æŒ‡å®šscopeï¼ŒæŒ‰ç…§ AGENT -> TASK -> SESSION -> GLOBAL é¡ºåºæŸ¥æ‰¾
      
        Args:
            key: é”®å
            default: é»˜è®¤å€¼
            scope: æŒ‡å®šä½œç”¨åŸŸ
          
        Returns:
            ä¸Šä¸‹æ–‡å€¼æˆ–é»˜è®¤å€¼
        """
        with self._lock:
            if scope is not None:
                item = self._contexts[scope.value].get(key)
                if item and not self._is_expired(item):
                    return item.value
                return default
          
            # æŒ‰ä¼˜å…ˆçº§æŸ¥æ‰¾
            search_order = [
                ContextScope.AGENT,
                ContextScope.TASK,
                ContextScope.SESSION,
                ContextScope.GLOBAL
            ]
          
            for s in search_order:
                item = self._contexts[s.value].get(key)
                if item and not self._is_expired(item):
                    return item.value
          
            return default
  
    def _is_expired(self, item: ContextItem) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¿‡æœŸ"""
        if item.ttl is None:
            return False
        elapsed = (datetime.now() - item.updated_at).total_seconds()
        return elapsed > item.ttl
  
    def delete(self, key: str, scope: ContextScope = ContextScope.SESSION) -> bool:
        """åˆ é™¤ä¸Šä¸‹æ–‡é¡¹"""
        with self._lock:
            if key in self._contexts[scope.value]:
                del self._contexts[scope.value][key]
                return True
            return False
  
    def clear(self, scope: Optional[ContextScope] = None) -> None:
        """æ¸…ç©ºä¸Šä¸‹æ–‡"""
        with self._lock:
            if scope is None:
                for s in self._contexts:
                    self._contexts[s] = {}
            else:
                self._contexts[scope.value] = {}
  
    def get_all(self, scope: ContextScope) -> Dict[str, Any]:
        """è·å–æŒ‡å®šä½œç”¨åŸŸçš„æ‰€æœ‰ä¸Šä¸‹æ–‡"""
        with self._lock:
            result = {}
            for key, item in self._contexts[scope.value].items():
                if not self._is_expired(item):
                    result[key] = item.value
            return result
  
    def create_child_context(self) -> 'ContextManager':
        """åˆ›å»ºå­ä¸Šä¸‹æ–‡ï¼ˆç»§æ‰¿å½“å‰ä¸Šä¸‹æ–‡ï¼‰"""
        child = ContextManager()
        with self._lock:
            # å¤åˆ¶å…¨å±€å’Œä¼šè¯ä¸Šä¸‹æ–‡
            for scope in [ContextScope.GLOBAL, ContextScope.SESSION]:
                for key, item in self._contexts[scope.value].items():
                    if not self._is_expired(item):
                        child._contexts[scope.value][key] = copy.deepcopy(item)
        return child
  
    def merge(self, other: 'ContextManager', 
              scope: ContextScope = ContextScope.SESSION) -> None:
        """åˆå¹¶å¦ä¸€ä¸ªä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„å†…å®¹"""
        with self._lock:
            for key, item in other._contexts[scope.value].items():
                if not other._is_expired(item):
                    self._contexts[scope.value][key] = copy.deepcopy(item)


@dataclass
class ExecutionContext:
    """
    æ‰§è¡Œä¸Šä¸‹æ–‡
  
    åŒ…å«å•æ¬¡ä»»åŠ¡æ‰§è¡Œæ‰€éœ€çš„æ‰€æœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯
    """
    task_id: str
    session_id: str
    user_id: Optional[str] = None
  
    # ä¸Šä¸‹æ–‡ç®¡ç†å™¨
    context_manager: ContextManager = field(default_factory=ContextManager)
  
    # ä»»åŠ¡ç›¸å…³
    task_name: str = ""
    task_description: str = ""
    task_status: str = "pending"
  
    # å†å²æ¶ˆæ¯
    message_history: List['Message'] = field(default_factory=list)
  
    # ä¸­é—´ç»“æœ
    intermediate_results: Dict[str, Any] = field(default_factory=dict)
  
    # æ—¶é—´ä¿¡æ¯
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
  
    def add_message(self, message: 'Message') -> None:
        """æ·»åŠ æ¶ˆæ¯åˆ°å†å²"""
        self.message_history.append(message)
        self.updated_at = datetime.now()
  
    def get_recent_messages(self, n: int = 10) -> List['Message']:
        """è·å–æœ€è¿‘næ¡æ¶ˆæ¯"""
        return self.message_history[-n:]
  
    def set_result(self, key: str, value: Any) -> None:
        """è®¾ç½®ä¸­é—´ç»“æœ"""
        self.intermediate_results[key] = {
            "value": value,
            "timestamp": datetime.now()
        }
        self.updated_at = datetime.now()
  
    def get_result(self, key: str, default: Any = None) -> Any:
        """è·å–ä¸­é—´ç»“æœ"""
        result = self.intermediate_results.get(key)
        if result:
            return result["value"]
        return default
  
    def to_prompt_context(self) -> str:
        """è½¬æ¢ä¸ºæç¤ºè¯ä¸Šä¸‹æ–‡"""
        context_parts = []
      
        # ä»»åŠ¡ä¿¡æ¯
        context_parts.append(f"## å½“å‰ä»»åŠ¡\n- ä»»åŠ¡å: {self.task_name}\n- æè¿°: {self.task_description}")
      
        # ä¼šè¯ä¸Šä¸‹æ–‡
        session_ctx = self.context_manager.get_all(ContextScope.SESSION)
        if session_ctx:
            context_parts.append("## ä¼šè¯ä¸Šä¸‹æ–‡\n" + "\n".join(
                f"- {k}: {v}" for k, v in session_ctx.items()
            ))
      
        # æœ€è¿‘å¯¹è¯
        recent_msgs = self.get_recent_messages(5)
        if recent_msgs:
            context_parts.append("## æœ€è¿‘å¯¹è¯")
            for msg in recent_msgs:
                context_parts.append(f"[{msg.sender_name}]: {msg.content[:200]}...")
      
        return "\n\n".join(context_parts)
```

### 4. é€šä¿¡åè®® (`core/communication.py`)

```python
"""
Agenté€šä¿¡ç³»ç»Ÿ
å®šä¹‰Agentä¹‹é—´çš„é€šä¿¡åè®®å’Œæ¶ˆæ¯ä¼ é€’æœºåˆ¶
"""
from abc import ABC, abstractmethod
from typing import Dict, List, Callable, Optional, Any, Awaitable
from dataclasses import dataclass, field
from enum import Enum
import asyncio
from collections import defaultdict
import logging

from .message import Message, MessageType


logger = logging.getLogger(__name__)


class CommunicationPattern(Enum):
    """é€šä¿¡æ¨¡å¼"""
    POINT_TO_POINT = "p2p"      # ç‚¹å¯¹ç‚¹
    BROADCAST = "broadcast"     # å¹¿æ’­
    PUBLISH_SUBSCRIBE = "pubsub" # å‘å¸ƒè®¢é˜…
    REQUEST_RESPONSE = "reqres"  # è¯·æ±‚å“åº”


@dataclass
class Subscription:
    """è®¢é˜…ä¿¡æ¯"""
    subscriber_id: str
    topic: str
    handler: Callable[[Message], Awaitable[None]]
    filter_func: Optional[Callable[[Message], bool]] = None
    priority: int = 0


class MessageBus:
    """
    æ¶ˆæ¯æ€»çº¿
  
    è´Ÿè´£Agentä¹‹é—´çš„æ¶ˆæ¯ä¼ é€’
    """
  
    def __init__(self):
        # ç‚¹å¯¹ç‚¹æ¶ˆæ¯é˜Ÿåˆ—: agent_id -> queue
        self._queues: Dict[str, asyncio.Queue] = defaultdict(asyncio.Queue)
      
        # å‘å¸ƒè®¢é˜…: topic -> list of subscriptions
        self._subscriptions: Dict[str, List[Subscription]] = defaultdict(list)
      
        # æ¶ˆæ¯å¤„ç†å™¨: agent_id -> handler
        self._handlers: Dict[str, Callable[[Message], Awaitable[Message]]] = {}
      
        # æ¶ˆæ¯å†å² (ç”¨äºè°ƒè¯•å’Œè¿½è¸ª)
        self._message_history: List[Message] = []
        self._max_history = 1000
      
        # è¿è¡ŒçŠ¶æ€
        self._running = False
        self._tasks: List[asyncio.Task] = []
  
    async def start(self):
        """å¯åŠ¨æ¶ˆæ¯æ€»çº¿"""
        self._running = True
        logger.info("MessageBus started")
  
    async def stop(self):
        """åœæ­¢æ¶ˆæ¯æ€»çº¿"""
        self._running = False
        for task in self._tasks:
            task.cancel()
        self._tasks.clear()
        logger.info("MessageBus stopped")
  
    # ========== ç‚¹å¯¹ç‚¹é€šä¿¡ ==========
  
    async def send(self, message: Message) -> None:
        """
        å‘é€ç‚¹å¯¹ç‚¹æ¶ˆæ¯
      
        Args:
            message: è¦å‘é€çš„æ¶ˆæ¯
        """
        if message.receiver is None:
            raise ValueError("Point-to-point message must have a receiver")
      
        self._record_message(message)
        await self._queues[message.receiver].put(message)
        logger.debug(f"Message sent from {message.sender_name} to {message.receiver_name}")
  
    async def receive(self, agent_id: str, timeout: Optional[float] = None) -> Optional[Message]:
        """
        æ¥æ”¶æ¶ˆæ¯
      
        Args:
            agent_id: æ¥æ”¶è€…ID
            timeout: è¶…æ—¶æ—¶é—´(ç§’)
          
        Returns:
            æ”¶åˆ°çš„æ¶ˆæ¯ï¼Œè¶…æ—¶è¿”å›None
        """
        try:
            if timeout:
                message = await asyncio.wait_for(
                    self._queues[agent_id].get(),
                    timeout=timeout
                )
            else:
                message = await self._queues[agent_id].get()
            return message
        except asyncio.TimeoutError:
            return None
  
    # ========== è¯·æ±‚å“åº”æ¨¡å¼ ==========
  
    async def request(self, message: Message, timeout: float = 30.0) -> Optional[Message]:
        """
        å‘é€è¯·æ±‚å¹¶ç­‰å¾…å“åº”
      
        Args:
            message: è¯·æ±‚æ¶ˆæ¯
            timeout: è¶…æ—¶æ—¶é—´
          
        Returns:
            å“åº”æ¶ˆæ¯
        """
        if message.receiver not in self._handlers:
            raise ValueError(f"No handler registered for {message.receiver}")
      
        self._record_message(message)
      
        try:
            handler = self._handlers[message.receiver]
            response = await asyncio.wait_for(handler(message), timeout=timeout)
            self._record_message(response)
            return response
        except asyncio.TimeoutError:
            logger.warning(f"Request timeout for {message.receiver_name}")
            return None
  
    def register_handler(self, agent_id: str, 
                         handler: Callable[[Message], Awaitable[Message]]) -> None:
        """
        æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
      
        Args:
            agent_id: Agent ID
            handler: å¤„ç†å‡½æ•°
        """
        self._handlers[agent_id] = handler
        logger.debug(f"Handler registered for agent {agent_id}")
  
    def unregister_handler(self, agent_id: str) -> None:
        """æ³¨é”€æ¶ˆæ¯å¤„ç†å™¨"""
        if agent_id in self._handlers:
            del self._handlers[agent_id]
  
    # ========== å‘å¸ƒè®¢é˜…æ¨¡å¼ ==========
  
    def subscribe(self, topic: str, subscriber_id: str,
                  handler: Callable[[Message], Awaitable[None]],
                  filter_func: Optional[Callable[[Message], bool]] = None,
                  priority: int = 0) -> None:
        """
        è®¢é˜…ä¸»é¢˜
      
        Args:
            topic: ä¸»é¢˜åç§°
            subscriber_id: è®¢é˜…è€…ID
            handler: æ¶ˆæ¯å¤„ç†å‡½æ•°
            filter_func: æ¶ˆæ¯è¿‡æ»¤å‡½æ•°
            priority: ä¼˜å…ˆçº§
        """
        subscription = Subscription(
            subscriber_id=subscriber_id,
            topic=topic,
            handler=handler,
            filter_func=filter_func,
            priority=priority
        )
        self._subscriptions[topic].append(subscription)
        # æŒ‰ä¼˜å…ˆçº§æ’åº
        self._subscriptions[topic].sort(key=lambda x: x.priority, reverse=True)
        logger.debug(f"{subscriber_id} subscribed to topic {topic}")
  
    def unsubscribe(self, topic: str, subscriber_id: str) -> None:
        """å–æ¶ˆè®¢é˜…"""
        self._subscriptions[topic] = [
            s for s in self._subscriptions[topic]
            if s.subscriber_id != subscriber_id
        ]
  
    async def publish(self, topic: str, message: Message) -> int:
        """
        å‘å¸ƒæ¶ˆæ¯åˆ°ä¸»é¢˜
      
        Args:
            topic: ä¸»é¢˜åç§°
            message: æ¶ˆæ¯
          
        Returns:
            æ¥æ”¶åˆ°æ¶ˆæ¯çš„è®¢é˜…è€…æ•°é‡
        """
        self._record_message(message)
      
        subscribers = self._subscriptions.get(topic, [])
        delivered = 0
      
        for subscription in subscribers:
            # åº”ç”¨è¿‡æ»¤å™¨
            if subscription.filter_func and not subscription.filter_func(message):
                continue
          
            try:
                await subscription.handler(message)
                delivered += 1
            except Exception as e:
                logger.error(f"Error delivering message to {subscription.subscriber_id}: {e}")
      
        logger.debug(f"Published message to topic {topic}, delivered to {delivered} subscribers")
        return delivered
  
    # ========== å¹¿æ’­ ==========
  
    async def broadcast(self, message: Message, 
                        exclude: Optional[List[str]] = None) -> None:
        """
        å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰Agent
      
        Args:
            message: æ¶ˆæ¯
            exclude: æ’é™¤çš„Agent IDåˆ—è¡¨
        """
        exclude = exclude or []
        self._record_message(message)
      
        for agent_id in self._queues.keys():
            if agent_id not in exclude and agent_id != message.sender:
                await self._queues[agent_id].put(message)
      
        logger.debug(f"Broadcast message from {message.sender_name}")
  
    # ========== è¾…åŠ©æ–¹æ³• ==========
  
    def _record_message(self, message: Message) -> None:
        """è®°å½•æ¶ˆæ¯åˆ°å†å²"""
        self._message_history.append(message)
        if len(self._message_history) > self._max_history:
            self._message_history = self._message_history[-self._max_history:]
  
    def get_message_history(self, 
                            limit: int = 100,
                            sender: Optional[str] = None,
                            receiver: Optional[str] = None) -> List[Message]:
        """è·å–æ¶ˆæ¯å†å²"""
        messages = self._message_history[-limit:]
      
        if sender:
            messages = [m for m in messages if m.sender == sender]
        if receiver:
            messages = [m for m in messages if m.receiver == receiver]
      
        return messages


class AgentCommunicator:
    """
    Agenté€šä¿¡å™¨
  
    å°è£…å•ä¸ªAgentçš„é€šä¿¡åŠŸèƒ½
    """
  
    def __init__(self, agent_id: str, agent_name: str, message_bus: MessageBus):
        self.agent_id = agent_id
        self.agent_name = agent_name
        self._bus = message_bus
        self._inbox: asyncio.Queue = asyncio.Queue()
  
    async def send_to(self, receiver_id: str, receiver_name: str,
                      content: str, msg_type: MessageType = MessageType.REQUEST,
                      **kwargs) -> None:
        """å‘é€æ¶ˆæ¯ç»™ç‰¹å®šAgent"""
        message = Message(
            sender=self.agent_id,
            sender_name=self.agent_name,
            receiver=receiver_id,
            receiver_name=receiver_name,
            content=content,
            msg_type=msg_type,
            **kwargs
        )
        await self._bus.send(message)
  
    async def request_from(self, receiver_id: str, receiver_name: str,
                           content: str, timeout: float = 30.0,
                           **kwargs) -> Optional[Message]:
        """å‘ç‰¹å®šAgentå‘é€è¯·æ±‚å¹¶ç­‰å¾…å“åº”"""
        message = Message(
            sender=self.agent_id,
            sender_name=self.agent_name,
            receiver=receiver_id,
            receiver_name=receiver_name,
            content=content,
            msg_type=MessageType.REQUEST,
            **kwargs
        )
        return await self._bus.request(message, timeout)
  
    async def broadcast(self, content: str, 
                        msg_type: MessageType = MessageType.INFORM,
                        **kwargs) -> None:
        """å¹¿æ’­æ¶ˆæ¯"""
        message = Message(
            sender=self.agent_id,
            sender_name=self.agent_name,
            content=content,
            msg_type=msg_type,
            **kwargs
        )
        await self._bus.broadcast(message, exclude=[self.agent_id])
  
    def subscribe(self, topic: str,
                  handler: Callable[[Message], Awaitable[None]],
                  filter_func: Optional[Callable[[Message], bool]] = None) -> None:
        """è®¢é˜…ä¸»é¢˜"""
        self._bus.subscribe(topic, self.agent_id, handler, filter_func)
  
    async def publish(self, topic: str, content: str, **kwargs) -> int:
        """å‘å¸ƒæ¶ˆæ¯åˆ°ä¸»é¢˜"""
        message = Message(
            sender=self.agent_id,
            sender_name=self.agent_name,
            content=content,
            **kwargs
        )
        return await self._bus.publish(topic, message)
```

### 5. ç¼–æ’è°ƒåº¦å™¨ (`core/orchestrator.py`)

```python
"""
Agentç¼–æ’è°ƒåº¦å™¨
è´Ÿè´£åè°ƒå¤šä¸ªAgentçš„å·¥ä½œæµç¨‹
"""
from typing import Dict, List, Optional, Any, Type
from dataclasses import dataclass, field
from enum import Enum
import asyncio
import logging

from .base_agent import BaseAgent, AgentConfig, AgentState
from .message import Message, MessageType
from .context import ExecutionContext, ContextManager, ContextScope
from .communication import MessageBus, AgentCommunicator


logger = logging.getLogger(__name__)


class OrchestrationMode(Enum):
    """ç¼–æ’æ¨¡å¼"""
    SEQUENTIAL = "sequential"   # é¡ºåºæ‰§è¡Œ
    PARALLEL = "parallel"       # å¹¶è¡Œæ‰§è¡Œ
    HIERARCHICAL = "hierarchical"  # å±‚çº§æ‰§è¡Œ(æœ‰ä¸»Agent)
    COLLABORATIVE = "collaborative"  # åä½œæ‰§è¡Œ


@dataclass
class TaskDefinition:
    """ä»»åŠ¡å®šä¹‰"""
    task_id: str
    name: str
    description: str
    input_data: Any
    assigned_agent: Optional[str] = None
    dependencies: List[str] = field(default_factory=list)
    priority: int = 0
    timeout: float = 300.0
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class TaskResult:
    """ä»»åŠ¡ç»“æœ"""
    task_id: str
    success: bool
    output: Any
    agent_id: str
    execution_time: float
    error: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


class Orchestrator:
    """
    ç¼–æ’è°ƒåº¦å™¨
  
    èŒè´£:
    - ç®¡ç†Agentç”Ÿå‘½å‘¨æœŸ
    - åè°ƒAgentä¹‹é—´çš„ä»»åŠ¡åˆ†é…
    - æ§åˆ¶æ‰§è¡Œæµç¨‹
    - æ”¶é›†å’Œæ±‡æ€»ç»“æœ
    """
  
    def __init__(self, mode: OrchestrationMode = OrchestrationMode.HIERARCHICAL):
        self.mode = mode
        self.agents: Dict[str, BaseAgent] = {}
        self.message_bus = MessageBus()
        self.context_manager = ContextManager()
      
        # ä¸»Agent (ç”¨äºHIERARCHICALæ¨¡å¼)
        self.primary_agent_id: Optional[str] = None
      
        # ä»»åŠ¡é˜Ÿåˆ—
        self._task_queue: asyncio.Queue = asyncio.Queue()
        self._results: Dict[str, TaskResult] = {}
      
        # è¿è¡ŒçŠ¶æ€
        self._running = False
  
    def register_agent(self, agent: BaseAgent, is_primary: bool = False) -> None:
        """
        æ³¨å†ŒAgent
      
        Args:
            agent: Agentå®ä¾‹
            is_primary: æ˜¯å¦ä¸ºä¸»Agent
        """
        self.agents[agent.id] = agent
      
        # åˆ›å»ºé€šä¿¡å™¨
        communicator = AgentCommunicator(agent.id, agent.name, self.message_bus)
        agent.communicator = communicator
      
        # æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
        self.message_bus.register_handler(agent.id, agent.run)
      
        if is_primary:
            self.primary_agent_id = agent.id
      
        logger.info(f"Agent registered: {agent.name} (ID: {agent.id})")
  
    def unregister_agent(self, agent_id: str) -> None:
        """æ³¨é”€Agent"""
        if agent_id in self.agents:
            self.message_bus.unregister_handler(agent_id)
            del self.agents[agent_id]
            if self.primary_agent_id == agent_id:
                self.primary_agent_id = None
  
    async def start(self) -> None:
        """å¯åŠ¨ç¼–æ’å™¨"""
        await self.message_bus.start()
        self._running = True
        logger.info("Orchestrator started")
  
    async def stop(self) -> None:
        """åœæ­¢ç¼–æ’å™¨"""
        self._running = False
        await self.message_bus.stop()
        logger.info("Orchestrator stopped")
  
    async def execute(self, task: TaskDefinition, 
                      context: Optional[ExecutionContext] = None) -> TaskResult:
        """
        æ‰§è¡Œå•ä¸ªä»»åŠ¡
      
        Args:
            task: ä»»åŠ¡å®šä¹‰
            context: æ‰§è¡Œä¸Šä¸‹æ–‡
          
        Returns:
            ä»»åŠ¡ç»“æœ
        """
        # åˆ›å»ºæˆ–ä½¿ç”¨ç°æœ‰ä¸Šä¸‹æ–‡
        if context is None:
            context = ExecutionContext(
                task_id=task.task_id,
                session_id=f"session_{task.task_id}",
                task_name=task.name,
                task_description=task.description
            )
      
        # æ ¹æ®ç¼–æ’æ¨¡å¼é€‰æ‹©æ‰§è¡Œç­–ç•¥
        if self.mode == OrchestrationMode.HIERARCHICAL:
            return await self._execute_hierarchical(task, context)
        elif self.mode == OrchestrationMode.SEQUENTIAL:
            return await self._execute_sequential(task, context)
        elif self.mode == OrchestrationMode.PARALLEL:
            return await self._execute_parallel(task, context)
        else:
            return await self._execute_collaborative(task, context)
  
    async def _execute_hierarchical(self, task: TaskDefinition, 
                                     context: ExecutionContext) -> TaskResult:
        """å±‚çº§æ‰§è¡Œ - ç”±ä¸»Agentåˆ†è§£å’Œåˆ†é…ä»»åŠ¡"""
        import time
        start_time = time.time()
      
        if not self.primary_agent_id:
            raise ValueError("No primary agent registered for hierarchical mode")
      
        primary_agent = self.agents[self.primary_agent_id]
      
        # 1. ä¸»Agentåˆ†æä»»åŠ¡
        analysis_message = Message(
            sender="orchestrator",
            sender_name="Orchestrator",
            receiver=primary_agent.id,
            receiver_name=primary_agent.name,
            content=f"""
è¯·åˆ†æä»¥ä¸‹ä»»åŠ¡å¹¶åˆ¶å®šæ‰§è¡Œè®¡åˆ’:

ä»»åŠ¡åç§°: {task.name}
ä»»åŠ¡æè¿°: {task.description}
è¾“å…¥æ•°æ®: {task.input_data}

å¯ç”¨çš„Agent:
{self._get_agents_info()}

è¯·è¿”å›JSONæ ¼å¼çš„æ‰§è¡Œè®¡åˆ’ï¼ŒåŒ…å«:
1. ä»»åŠ¡åˆ†è§£
2. æ¯ä¸ªå­ä»»åŠ¡åˆ†é…ç»™å“ªä¸ªAgent
3. æ‰§è¡Œé¡ºåºå’Œä¾èµ–å…³ç³»
""",
            msg_type=MessageType.TASK
        )
      
        # è®¾ç½®ä»»åŠ¡ä¸Šä¸‹æ–‡
        context.context_manager.set("current_task", task.to_dict() if hasattr(task, 'to_dict') else str(task), 
                                    scope=ContextScope.TASK)
      
        try:
            # æ‰§è¡Œåˆ†æ
            plan_response = await self.message_bus.request(analysis_message, timeout=task.timeout)
          
            if plan_response is None:
                return TaskResult(
                    task_id=task.task_id,
                    success=False,
                    output=None,
                    agent_id=primary_agent.id,
                    execution_time=time.time() - start_time,
                    error="Primary agent timeout"
                )
          
            # 2. æ‰§è¡Œå­ä»»åŠ¡ (ç®€åŒ–ç‰ˆï¼Œå®é™…éœ€è¦è§£ææ‰§è¡Œè®¡åˆ’)
            final_response = await self._execute_subtasks(plan_response.content, context)
          
            return TaskResult(
                task_id=task.task_id,
                success=True,
                output=final_response,
                agent_id=primary_agent.id,
                execution_time=time.time() - start_time
            )
          
        except Exception as e:
            logger.error(f"Task execution failed: {e}")
            return TaskResult(
                task_id=task.task_id,
                success=False,
                output=None,
                agent_id=primary_agent.id,
                execution_time=time.time() - start_time,
                error=str(e)
            )
  
    async def _execute_sequential(self, task: TaskDefinition,
                                   context: ExecutionContext) -> TaskResult:
        """é¡ºåºæ‰§è¡Œ - æŒ‰é¡ºåºè°ƒç”¨å„Agent"""
        import time
        start_time = time.time()
      
        current_output = task.input_data
        agent_chain = task.metadata.get("agent_chain", list(self.agents.keys()))
      
        for agent_id in agent_chain:
            agent = self.agents.get(agent_id)
            if not agent:
                continue
          
            message = Message(
                sender="orchestrator",
                sender_name="Orchestrator",
                receiver=agent.id,
                receiver_name=agent.name,
                content=str(current_output),
                msg_type=MessageType.TASK
            )
          
            response = await self.message_bus.request(message)
            if response:
                current_output = response.content
                context.add_message(response)
      
        return TaskResult(
            task_id=task.task_id,
            success=True,
            output=current_output,
            agent_id="sequential",
            execution_time=time.time() - start_time
        )
  
    async def _execute_parallel(self, task: TaskDefinition,
                                context: ExecutionContext) -> TaskResult:
        """å¹¶è¡Œæ‰§è¡Œ - åŒæ—¶è°ƒç”¨å¤šä¸ªAgent"""
        import time
        start_time = time.time()
      
        tasks = []
        for agent_id, agent in self.agents.items():
            message = Message(
                sender="orchestrator",
                sender_name="Orchestrator",
                receiver=agent.id,
                receiver_name=agent.name,
                content=str(task.input_data),
                msg_type=MessageType.TASK
            )
            tasks.append(self.message_bus.request(message))
      
        responses = await asyncio.gather(*tasks, return_exceptions=True)
      
        # æ±‡æ€»ç»“æœ
        outputs = []
        for resp in responses:
            if isinstance(resp, Message):
                outputs.append(resp.content)
      
        return TaskResult(
            task_id=task.task_id,
            success=True,
            output=outputs,
            agent_id="parallel",
            execution_time=time.time() - start_time
        )
  
    async def _execute_collaborative(self, task: TaskDefinition,
                                      context: ExecutionContext) -> TaskResult:
        """åä½œæ‰§è¡Œ - Agentä¹‹é—´è‡ªç”±é€šä¿¡åä½œ"""
        # TODO: å®ç°åä½œæ¨¡å¼
        raise NotImplementedError("Collaborative mode not implemented yet")
  
    async def _execute_subtasks(self, plan: str, context: ExecutionContext) -> str:
        """æ‰§è¡Œå­ä»»åŠ¡"""
        # ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦è§£ææ‰§è¡Œè®¡åˆ’
        return plan
  
    def _get_agents_info(self) -> str:
        """è·å–æ‰€æœ‰Agentä¿¡æ¯"""
        info_lines = []
        for agent_id, agent in self.agents.items():
            info_lines.append(f"- {agent.name} ({agent.role}): {agent.config.description}")
        return "\n".join(info_lines)
  
    def get_status(self) -> Dict[str, Any]:
        """è·å–ç¼–æ’å™¨çŠ¶æ€"""
        return {
            "mode": self.mode.value,
            "running": self._running,
            "agents": {
                agent_id: agent.get_state_info()
                for agent_id, agent in self.agents.items()
            },
            "primary_agent": self.primary_agent_id,
            "pending_tasks": self._task_queue.qsize()
        }
```

---

## ğŸ› ï¸ å·¥å…·ç³»ç»Ÿè®¾è®¡

### å·¥å…·åŸºç±» (`tools/base_tool.py`)

```python
"""
å·¥å…·åŸºç±»
å®šä¹‰æ‰€æœ‰å·¥å…·çš„é€šç”¨æ¥å£
"""
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from enum import Enum


class ToolCategory(Enum):
    """å·¥å…·ç±»åˆ«"""
    COMPUTATION = "computation"     # è®¡ç®—ç±»
    DATA = "data"                   # æ•°æ®å¤„ç†ç±»
    FILE = "file"                   # æ–‡ä»¶æ“ä½œç±»
    WEB = "web"                     # ç½‘ç»œç±»
    CODE = "code"                   # ä»£ç ç±»
    VISUALIZATION = "visualization" # å¯è§†åŒ–ç±»
    DOMAIN = "domain"               # é¢†åŸŸä¸“ç”¨ç±»


@dataclass
class ToolParameter:
    """å·¥å…·å‚æ•°å®šä¹‰"""
    name: str
    type: str
    description: str
    required: bool = True
    default: Any = None
    enum: Optional[List[Any]] = None


@dataclass
class ToolResult:
    """å·¥å…·æ‰§è¡Œç»“æœ"""
    success: bool
    data: Any
    error: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ToolSchema:
    """å·¥å…·æ¨¡å¼å®šä¹‰ (ç”¨äºLLMç†è§£)"""
    name: str
    description: str
    category: ToolCategory
    parameters: List[ToolParameter]
    returns: str
    examples: List[Dict[str, Any]] = field(default_factory=list)
  
    def to_openai_function(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºOpenAI Functionæ ¼å¼"""
        properties = {}
        required = []
      
        for param in self.parameters:
            prop = {
                "type": param.type,
                "description": param.description
            }
            if param.enum:
                prop["enum"] = param.enum
            properties[param.name] = prop
          
            if param.required:
                required.append(param.name)
      
        return {
            "name": self.name,
            "description": self.description,
            "parameters": {
                "type": "object",
                "properties": properties,
                "required": required
            }
        }


class BaseTool(ABC):
    """
    å·¥å…·åŸºç±»
  
    æ‰€æœ‰å·¥å…·éƒ½éœ€è¦ç»§æ‰¿æ­¤ç±»å¹¶å®ç°executeæ–¹æ³•
    """
  
    def __init__(self):
        self._schema: Optional[ToolSchema] = None
  
    @property
    @abstractmethod
    def name(self) -> str:
        """å·¥å…·åç§°"""
        pass
  
    @property
    @abstractmethod
    def description(self) -> str:
        """å·¥å…·æè¿°"""
        pass
  
    @property
    @abstractmethod
    def category(self) -> ToolCategory:
        """å·¥å…·ç±»åˆ«"""
        pass
  
    @property
    def schema(self) -> ToolSchema:
        """è·å–å·¥å…·æ¨¡å¼"""
        if self._schema is None:
            self._schema = ToolSchema(
                name=self.name,
                description=self.description,
                category=self.category,
                parameters=self.get_parameters(),
                returns=self.get_return_description(),
                examples=self.get_examples()
            )
        return self._schema
  
    @abstractmethod
    def get_parameters(self) -> List[ToolParameter]:
        """è·å–å‚æ•°å®šä¹‰"""
        pass
  
    @abstractmethod
    def get_return_description(self) -> str:
        """è·å–è¿”å›å€¼æè¿°"""
        pass
  
    def get_examples(self) -> List[Dict[str, Any]]:
        """è·å–ä½¿ç”¨ç¤ºä¾‹"""
        return []
  
    @abstractmethod
    async def execute(self, **kwargs) -> ToolResult:
        """
        æ‰§è¡Œå·¥å…·
      
        Args:
            **kwargs: å·¥å…·å‚æ•°
          
        Returns:
            ToolResult: æ‰§è¡Œç»“æœ
        """
        pass
  
    def validate_parameters(self, **kwargs) -> Optional[str]:
        """
        éªŒè¯å‚æ•°
      
        Returns:
            é”™è¯¯ä¿¡æ¯ï¼ŒNoneè¡¨ç¤ºéªŒè¯é€šè¿‡
        """
        for param in self.get_parameters():
            if param.required and param.name not in kwargs:
                return f"Missing required parameter: {param.name}"
        return None
  
    async def safe_execute(self, **kwargs) -> ToolResult:
        """
        å®‰å…¨æ‰§è¡Œ (å¸¦å‚æ•°éªŒè¯å’Œå¼‚å¸¸å¤„ç†)
        """
        # éªŒè¯å‚æ•°
        error = self.validate_parameters(**kwargs)
        if error:
            return ToolResult(success=False, data=None, error=error)
      
        # æ‰§è¡Œ
        try:
            return await self.execute(**kwargs)
        except Exception as e:
            return ToolResult(
                success=False,
                data=None,
                error=f"Tool execution failed: {str(e)}"
            )
```

### å›ºåºŸé¢†åŸŸå·¥å…·ç¤ºä¾‹ (`tools/domain/emission_calculator.py`)

```python
"""
å›ºä½“åºŸç‰©æ’æ”¾è®¡ç®—å·¥å…·
"""
from typing import Dict, Any, List
from ..base_tool import BaseTool, ToolCategory, ToolParameter, ToolResult


class EmissionCalculator(BaseTool):
    """
    æ¸©å®¤æ°”ä½“æ’æ”¾è®¡ç®—å·¥å…·
  
    åŸºäºIPCCæŒ‡å—è®¡ç®—å›ºä½“åºŸç‰©å¤„ç†è¿‡ç¨‹ä¸­çš„æ¸©å®¤æ°”ä½“æ’æ”¾
    """
  
    # æ’æ”¾å› å­ (kg CO2e/å¨åºŸç‰©)
    EMISSION_FACTORS = {
        "landfill": {
            "food_waste": 580,
            "paper": 1100,
            "wood": 850,
            "textile": 450,
            "plastic": 21,
            "glass": 8,
            "metal": 12,
            "other": 200
        },
        "incineration": {
            "food_waste": 220,
            "paper": 1400,
            "wood": 1200,
            "textile": 2100,
            "plastic": 2700,
            "glass": 5,
            "metal": 10,
            "other": 500
        },
        "composting": {
            "food_waste": 125,
            "paper": 80,
            "wood": 100,
            "garden_waste": 90
        },
        "recycling": {
            "paper": -500,
            "plastic": -1200,
            "glass": -300,
            "metal": -3000
        }
    }
  
    @property
    def name(self) -> str:
        return "emission_calculator"
  
    @property
    def description(self) -> str:
        return "è®¡ç®—å›ºä½“åºŸç‰©å¤„ç†è¿‡ç¨‹ä¸­çš„æ¸©å®¤æ°”ä½“æ’æ”¾é‡(kg CO2e)"
  
    @property
    def category(self) -> ToolCategory:
        return ToolCategory.DOMAIN
  
    def get_parameters(self) -> List[ToolParameter]:
        return [
            ToolParameter(
                name="waste_type",
                type="string",
                description="åºŸç‰©ç±»å‹",
                required=True,
                enum=["food_waste", "paper", "wood", "textile", "plastic", 
                      "glass", "metal", "garden_waste", "other"]
            ),
            ToolParameter(
                name="treatment_method",
                type="string",
                description="å¤„ç†æ–¹å¼",
                required=True,
                enum=["landfill", "incineration", "composting", "recycling"]
            ),
            ToolParameter(
                name="quantity",
                type="number",
                description="åºŸç‰©é‡(å¨)",
                required=True
            ),
            ToolParameter(
                name="include_transport",
                type="boolean",
                description="æ˜¯å¦åŒ…å«è¿è¾“æ’æ”¾",
                required=False,
                default=False
            ),
            ToolParameter(
                name="transport_distance",
                type="number",
                description="è¿è¾“è·ç¦»(km)",
                required=False,
                default=0
            )
        ]
  
    def get_return_description(self) -> str:
        return "è¿”å›åŒ…å«æ’æ”¾é‡è®¡ç®—ç»“æœçš„å­—å…¸ï¼ŒåŒ…æ‹¬ç›´æ¥æ’æ”¾ã€è¿è¾“æ’æ”¾å’Œæ€»æ’æ”¾"
  
    def get_examples(self) -> List[Dict[str, Any]]:
        return [
            {
                "input": {
                    "waste_type": "food_waste",
                    "treatment_method": "composting",
                    "quantity": 100
                },
                "output": {
                    "direct_emission": 12500,
                    "transport_emission": 0,
                    "total_emission": 12500,
                    "unit": "kg CO2e"
                }
            }
        ]
  
    async def execute(self, **kwargs) -> ToolResult:
        waste_type = kwargs["waste_type"]
        treatment_method = kwargs["treatment_method"]
        quantity = kwargs["quantity"]
        include_transport = kwargs.get("include_transport", False)
        transport_distance = kwargs.get("transport_distance", 0)
      
        # è·å–æ’æ”¾å› å­
        method_factors = self.EMISSION_FACTORS.get(treatment_method, {})
        factor = method_factors.get(waste_type)
      
        if factor is None:
            return ToolResult(
                success=False,
                data=None,
                error=f"No emission factor available for {waste_type} with {treatment_method}"
            )
      
        # è®¡ç®—ç›´æ¥æ’æ”¾
        direct_emission = factor * quantity
      
        # è®¡ç®—è¿è¾“æ’æ”¾ (å‡è®¾0.1 kg CO2e/å¨/km)
        transport_emission = 0
        if include_transport and transport_distance > 0:
            transport_emission = 0.1 * quantity * transport_distance
      
        total_emission = direct_emission + transport_emission
      
        result = {
            "waste_type": waste_type,
            "treatment_method": treatment_method,
            "quantity_tonnes": quantity,
            "emission_factor": factor,
            "direct_emission_kgCO2e": round(direct_emission, 2),
            "transport_emission_kgCO2e": round(transport_emission, 2),
            "total_emission_kgCO2e": round(total_emission, 2),
            "total_emission_tCO2e": round(total_emission / 1000, 4)
        }
      
        return ToolResult(
            success=True,
            data=result,
            metadata={
                "source": "IPCC Guidelines adapted",
                "methodology": "Tier 1"
            }
        )
```

---

## ğŸ¤– Agentå®ç°ç¤ºä¾‹

### è§„åˆ’Agent (`agents/planner_agent.py`)

```python
"""
è§„åˆ’Agent
è´Ÿè´£ä»»åŠ¡åˆ†æã€åˆ†è§£å’Œæ‰§è¡Œè®¡åˆ’åˆ¶å®š
"""
from typing import Dict, List, Any
import json

from ..core.base_agent import BaseAgent, AgentConfig, AgentState
from ..core.message import Message, MessageType, ThinkResult, ActionResult
from ..core.context import ExecutionContext


class PlannerAgent(BaseAgent):
    """
    è§„åˆ’Agent
  
    èŒè´£:
    - åˆ†æç”¨æˆ·éœ€æ±‚
    - åˆ†è§£å¤æ‚ä»»åŠ¡
    - åˆ¶å®šæ‰§è¡Œè®¡åˆ’
    - åè°ƒå…¶ä»–Agent
    """
  
    def __init__(self, config: AgentConfig = None):
        if config is None:
            config = AgentConfig(
                name="Planner",
                role="ä»»åŠ¡è§„åˆ’å¸ˆ",
                description="è´Ÿè´£åˆ†æä»»åŠ¡ã€åˆ¶å®šæ‰§è¡Œè®¡åˆ’å¹¶åè°ƒå…¶ä»–Agentå®Œæˆå·¥ä½œ",
                system_prompt=self._get_system_prompt()
            )
        super().__init__(config)
        self.available_agents: Dict[str, str] = {}  # agent_name -> description
  
    def _get_system_prompt(self) -> str:
        return """ä½ æ˜¯ä¸€ä¸ªå›ºä½“åºŸç‰©é¢†åŸŸçš„ä»»åŠ¡è§„åˆ’ä¸“å®¶ã€‚ä½ çš„èŒè´£æ˜¯:

1. **ä»»åŠ¡åˆ†æ**: ç†è§£ç”¨æˆ·çš„éœ€æ±‚ï¼Œè¯†åˆ«ä»»åŠ¡ç±»å‹å’Œå¤æ‚åº¦
2. **ä»»åŠ¡åˆ†è§£**: å°†å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºå¯æ‰§è¡Œçš„å­ä»»åŠ¡
3. **èµ„æºè§„åˆ’**: ç¡®å®šæ¯ä¸ªå­ä»»åŠ¡éœ€è¦å“ªäº›Agentå’Œå·¥å…·
4. **é¡ºåºå®‰æ’**: ç¡®å®šå­ä»»åŠ¡çš„æ‰§è¡Œé¡ºåºå’Œä¾èµ–å…³ç³»
5. **ç»“æœæ•´åˆ**: æ•´åˆå„å­ä»»åŠ¡çš„ç»“æœï¼Œå½¢æˆæœ€ç»ˆè¾“å‡º

å›ºä½“åºŸç‰©é¢†åŸŸçŸ¥è¯†:
- ç†Ÿæ‚‰å›ºåºŸåˆ†ç±»ã€å¤„ç†ã€èµ„æºåŒ–åˆ©ç”¨ç­‰ä¸“ä¸šçŸ¥è¯†
- äº†è§£ç›¸å…³æ”¿ç­–æ³•è§„å’ŒæŠ€æœ¯æ ‡å‡†
- æŒæ¡ç”Ÿå‘½å‘¨æœŸè¯„ä¼°(LCA)ã€ç¢³æ’æ”¾è®¡ç®—ç­‰æ–¹æ³•

è¾“å‡ºæ ¼å¼è¦æ±‚:
å½“åˆ¶å®šè®¡åˆ’æ—¶ï¼Œè¯·ä½¿ç”¨JSONæ ¼å¼è¾“å‡ºï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µ:
{
    "task_analysis": "ä»»åŠ¡åˆ†æ",
    "subtasks": [
        {
            "id": "å­ä»»åŠ¡ID",
            "name": "å­ä»»åŠ¡åç§°",
            "description": "å­ä»»åŠ¡æè¿°",
            "assigned_agent": "åˆ†é…çš„Agent",
            "dependencies": ["ä¾èµ–çš„å­ä»»åŠ¡ID"],
            "expected_output": "é¢„æœŸè¾“å‡º"
        }
    ],
    "execution_order": ["æŒ‰é¡ºåºæ’åˆ—çš„å­ä»»åŠ¡ID"],
    "estimated_time": "é¢„è®¡å®Œæˆæ—¶é—´"
}"""
  
    def set_available_agents(self, agents: Dict[str, str]) -> None:
        """è®¾ç½®å¯ç”¨çš„Agentä¿¡æ¯"""
        self.available_agents = agents
  
    async def think(self, input_message: Message) -> ThinkResult:
        """
        åˆ†æä»»åŠ¡å¹¶è§„åˆ’
        """
        self.state = AgentState.THINKING
      
        # æ„å»ºæç¤º
        prompt = self._build_planning_prompt(input_message)
      
        # è°ƒç”¨LLM (è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦è°ƒç”¨LLM)
        # response = await self.llm.generate(prompt)
      
        # è§£æLLMå“åº”ï¼Œæå–è®¡åˆ’
        plan = self._parse_plan(input_message.content)
      
        return ThinkResult(
            action="create_plan",
            reasoning="åŸºäºä»»åŠ¡æè¿°ï¼Œåˆ¶å®šäº†æ‰§è¡Œè®¡åˆ’",
            plan=plan.get("execution_order", []),
            tools_needed=self._extract_tools_needed(plan),
            confidence=0.85,
            metadata={"plan": plan}
        )
  
    async def act(self, think_result: ThinkResult) -> ActionResult:
        """
        æ‰§è¡Œè®¡åˆ’ï¼ˆåˆ†å‘ä»»åŠ¡ç»™å…¶ä»–Agentï¼‰
        """
        self.state = AgentState.EXECUTING
      
        plan = think_result.metadata.get("plan", {})
      
        # æ ¼å¼åŒ–è¾“å‡º
        output = self._format_plan_output(plan)
      
        return ActionResult(
            success=True,
            content=output,
            metadata={"plan": plan}
        )
  
    def _build_planning_prompt(self, message: Message) -> str:
        """æ„å»ºè§„åˆ’æç¤ºè¯"""
        agents_info = "\n".join([
            f"- {name}: {desc}" 
            for name, desc in self.available_agents.items()
        ])
      
        return f"""è¯·åˆ†æä»¥ä¸‹ä»»åŠ¡å¹¶åˆ¶å®šæ‰§è¡Œè®¡åˆ’:

## ç”¨æˆ·éœ€æ±‚
{message.content}

## å¯ç”¨Agent
{agents_info if agents_info else "æš‚æ— å…¶ä»–ä¸“ä¸šAgent"}

## ä¸Šä¸‹æ–‡ä¿¡æ¯
{message.metadata.get('context', 'æ— ')}

è¯·åˆ¶å®šè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ã€‚"""
  
    def _parse_plan(self, task_description: str) -> Dict[str, Any]:
        """è§£æä»»åŠ¡ç”Ÿæˆè®¡åˆ’ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        # å®é™…åº”è¯¥è°ƒç”¨LLMç”Ÿæˆè®¡åˆ’
        # è¿™é‡Œè¿”å›ä¸€ä¸ªç¤ºä¾‹è®¡åˆ’
        return {
            "task_analysis": f"åˆ†æä»»åŠ¡: {task_description[:100]}...",
            "subtasks": [
                {
                    "id": "task_1",
                    "name": "æ•°æ®æ”¶é›†ä¸åˆ†æ",
                    "description": "æ”¶é›†ç›¸å…³æ•°æ®å¹¶è¿›è¡Œåˆæ­¥åˆ†æ",
                    "assigned_agent": "DataAgent",
                    "dependencies": [],
                    "expected_output": "åˆ†ææŠ¥å‘Š"
                },
                {
                    "id": "task_2",
                    "name": "æŠ¥å‘Šæ’°å†™",
                    "description": "åŸºäºåˆ†æç»“æœæ’°å†™æŠ¥å‘Š",
                    "assigned_agent": "WriterAgent",
                    "dependencies": ["task_1"],
                    "expected_output": "å®Œæ•´æŠ¥å‘Š"
                }
            ],
            "execution_order": ["task_1", "task_2"],
            "estimated_time": "30åˆ†é’Ÿ"
        }
  
    def _extract_tools_needed(self, plan: Dict) -> List[str]:
        """ä»è®¡åˆ’ä¸­æå–éœ€è¦çš„å·¥å…·"""
        tools = set()
        for subtask in plan.get("subtasks", []):
            tools.update(subtask.get("tools", []))
        return list(tools)
  
    def _format_plan_output(self, plan: Dict) -> str:
        """æ ¼å¼åŒ–è®¡åˆ’è¾“å‡º"""
        output_lines = [
            "# æ‰§è¡Œè®¡åˆ’",
            "",
            f"## ä»»åŠ¡åˆ†æ",
            plan.get("task_analysis", ""),
            "",
            "## å­ä»»åŠ¡åˆ—è¡¨",
        ]
      
        for i, subtask in enumerate(plan.get("subtasks", []), 1):
            output_lines.extend([
                f"### {i}. {subtask['name']}",
                f"- æè¿°: {subtask['description']}",
                f"- è´Ÿè´£Agent: {subtask['assigned_agent']}",
                f"- ä¾èµ–: {', '.join(subtask['dependencies']) or 'æ— '}",
                f"- é¢„æœŸè¾“å‡º: {subtask['expected_output']}",
                ""
            ])
      
        output_lines.extend([
            "## æ‰§è¡Œé¡ºåº",
            " -> ".join(plan.get("execution_order", [])),
            "",
            f"## é¢„è®¡å®Œæˆæ—¶é—´: {plan.get('estimated_time', 'æœªçŸ¥')}"
        ])
      
        return "\n".join(output_lines)
```

---

## ğŸ“‹ å·¥ä½œæµæ¨¡æ¿

### ç ”ç©¶å·¥ä½œæµ (`workflows/research_workflow.py`)

```python
"""
ç§‘ç ”å·¥ä½œæµ
ç”¨äºå›ºåºŸé¢†åŸŸçš„ç§‘ç ”è¾…åŠ©ä»»åŠ¡
"""
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum

from swagent.core.orchestrator import Orchestrator, TaskDefinition, OrchestrationMode
from swagent.core.context import ExecutionContext
from swagent.agents.planner_agent import PlannerAgent
from swagent.agents.researcher_agent import ResearcherAgent
from swagent.agents.data_agent import DataAgent
from swagent.agents.writer_agent import WriterAgent
from swagent.agents.reviewer_agent import ReviewerAgent


class ResearchPhase(Enum):
    """ç ”ç©¶é˜¶æ®µ"""
    LITERATURE_REVIEW = "literature_review"    # æ–‡çŒ®ç»¼è¿°
    DATA_COLLECTION = "data_collection"        # æ•°æ®æ”¶é›†
    DATA_ANALYSIS = "data_analysis"            # æ•°æ®åˆ†æ
    MODELING = "modeling"                      # å»ºæ¨¡
    WRITING = "writing"                        # è®ºæ–‡æ’°å†™
    REVIEW = "review"                          # å®¡æ ¸ä¿®æ”¹


@dataclass
class ResearchConfig:
    """ç ”ç©¶ä»»åŠ¡é…ç½®"""
    topic: str                                  # ç ”ç©¶ä¸»é¢˜
    research_type: str = "ç»¼è¿°"                 # ç ”ç©¶ç±»å‹
    target_journal: Optional[str] = None        # ç›®æ ‡æœŸåˆŠ
    word_count: int = 5000                      # å­—æ•°è¦æ±‚
    include_phases: List[ResearchPhase] = None  # åŒ…å«çš„é˜¶æ®µ
    data_sources: List[str] = None              # æ•°æ®æ¥æº
    keywords: List[str] = None                  # å…³é”®è¯
  
    def __post_init__(self):
        if self.include_phases is None:
            self.include_phases = list(ResearchPhase)
        if self.data_sources is None:
            self.data_sources = ["Web of Science", "CNKI", "Scopus"]
        if self.keywords is None:
            self.keywords = []


class ResearchWorkflow:
    """
    ç§‘ç ”å·¥ä½œæµ
  
    åè°ƒå¤šä¸ªAgentå®Œæˆç§‘ç ”ä»»åŠ¡
    """
  
    def __init__(self, config: ResearchConfig):
        self.config = config
        self.orchestrator = Orchestrator(mode=OrchestrationMode.HIERARCHICAL)
        self._setup_agents()
        self.results: Dict[str, Any] = {}
  
    def _setup_agents(self) -> None:
        """è®¾ç½®Agent"""
        # è§„åˆ’Agent (ä¸»Agent)
        planner = PlannerAgent()
        self.orchestrator.register_agent(planner, is_primary=True)
      
        # ç ”ç©¶Agent
        # researcher = ResearcherAgent()
        # self.orchestrator.register_agent(researcher)
      
        # æ•°æ®Agent
        # data_agent = DataAgent()
        # self.orchestrator.register_agent(data_agent)
      
        # å†™ä½œAgent
        # writer = WriterAgent()
        # self.orchestrator.register_agent(writer)
      
        # å®¡æ ¸Agent
        # reviewer = ReviewerAgent()
        # self.orchestrator.register_agent(reviewer)
  
    async def run(self) -> Dict[str, Any]:
        """
        è¿è¡Œç ”ç©¶å·¥ä½œæµ
      
        Returns:
            ç ”ç©¶ç»“æœ
        """
        await self.orchestrator.start()
      
        try:
            # åˆ›å»ºä¸»ä»»åŠ¡
            main_task = TaskDefinition(
                task_id="research_main",
                name=f"ç ”ç©¶ä»»åŠ¡: {self.config.topic}",
                description=self._build_task_description(),
                input_data={
                    "topic": self.config.topic,
                    "type": self.config.research_type,
                    "keywords": self.config.keywords,
                    "data_sources": self.config.data_sources
                }
            )
          
            # æ‰§è¡Œä»»åŠ¡
            result = await self.orchestrator.execute(main_task)
          
            self.results = {
                "success": result.success,
                "output": result.output,
                "execution_time": result.execution_time,
                "metadata": result.metadata
            }
          
            return self.results
          
        finally:
            await self.orchestrator.stop()
  
    def _build_task_description(self) -> str:
        """æ„å»ºä»»åŠ¡æè¿°"""
        phases_str = ", ".join([p.value for p in self.config.include_phases])
      
        return f"""
ç ”ç©¶ä¸»é¢˜: {self.config.topic}
ç ”ç©¶ç±»å‹: {self.config.research_type}
ç›®æ ‡æœŸåˆŠ: {self.config.target_journal or 'æœªæŒ‡å®š'}
å­—æ•°è¦æ±‚: {self.config.word_count}å­—
ç ”ç©¶é˜¶æ®µ: {phases_str}
æ•°æ®æ¥æº: {', '.join(self.config.data_sources)}
å…³é”®è¯: {', '.join(self.config.keywords) if self.config.keywords else 'å¾…ç¡®å®š'}
"""
  
    async def run_phase(self, phase: ResearchPhase) -> Dict[str, Any]:
        """
        è¿è¡Œå•ä¸ªç ”ç©¶é˜¶æ®µ
      
        Args:
            phase: ç ”ç©¶é˜¶æ®µ
          
        Returns:
            é˜¶æ®µç»“æœ
        """
        phase_tasks = {
            ResearchPhase.LITERATURE_REVIEW: self._run_literature_review,
            ResearchPhase.DATA_COLLECTION: self._run_data_collection,
            ResearchPhase.DATA_ANALYSIS: self._run_data_analysis,
            ResearchPhase.MODELING: self._run_modeling,
            ResearchPhase.WRITING: self._run_writing,
            ResearchPhase.REVIEW: self._run_review
        }
      
        task_func = phase_tasks.get(phase)
        if task_func:
            return await task_func()
        else:
            raise ValueError(f"Unknown phase: {phase}")
  
    async def _run_literature_review(self) -> Dict[str, Any]:
        """æ‰§è¡Œæ–‡çŒ®ç»¼è¿°é˜¶æ®µ"""
        task = TaskDefinition(
            task_id="literature_review",
            name="æ–‡çŒ®ç»¼è¿°",
            description=f"é’ˆå¯¹'{self.config.topic}'è¿›è¡Œæ–‡çŒ®æ£€ç´¢å’Œç»¼è¿°",
            input_data={
                "keywords": self.config.keywords,
                "sources": self.config.data_sources,
                "recent_years": 5
            }
        )
        result = await self.orchestrator.execute(task)
        self.results["literature_review"] = result
        return result.__dict__
  
    async def _run_data_collection(self) -> Dict[str, Any]:
        """æ‰§è¡Œæ•°æ®æ”¶é›†é˜¶æ®µ"""
        task = TaskDefinition(
            task_id="data_collection",
            name="æ•°æ®æ”¶é›†",
            description=f"æ”¶é›†'{self.config.topic}'ç›¸å…³æ•°æ®",
            input_data={
                "sources": self.config.data_sources
            },
            dependencies=["literature_review"]
        )
        result = await self.orchestrator.execute(task)
        self.results["data_collection"] = result
        return result.__dict__
  
    async def _run_data_analysis(self) -> Dict[str, Any]:
        """æ‰§è¡Œæ•°æ®åˆ†æé˜¶æ®µ"""
        task = TaskDefinition(
            task_id="data_analysis",
            name="æ•°æ®åˆ†æ",
            description="å¯¹æ”¶é›†çš„æ•°æ®è¿›è¡Œç»Ÿè®¡åˆ†æ",
            input_data={
                "collected_data": self.results.get("data_collection", {})
            },
            dependencies=["data_collection"]
        )
        result = await self.orchestrator.execute(task)
        self.results["data_analysis"] = result
        return result.__dict__
  
    async def _run_modeling(self) -> Dict[str, Any]:
        """æ‰§è¡Œå»ºæ¨¡é˜¶æ®µ"""
        task = TaskDefinition(
            task_id="modeling",
            name="å»ºæ¨¡åˆ†æ",
            description="æ„å»ºåˆ†ææ¨¡å‹",
            input_data={
                "analysis_results": self.results.get("data_analysis", {})
            },
            dependencies=["data_analysis"]
        )
        result = await self.orchestrator.execute(task)
        self.results["modeling"] = result
        return result.__dict__
  
    async def _run_writing(self) -> Dict[str, Any]:
        """æ‰§è¡Œè®ºæ–‡æ’°å†™é˜¶æ®µ"""
        task = TaskDefinition(
            task_id="writing",
            name="è®ºæ–‡æ’°å†™",
            description=f"æ’°å†™{self.config.word_count}å­—çš„ç ”ç©¶è®ºæ–‡",
            input_data={
                "all_results": self.results,
                "target_journal": self.config.target_journal,
                "word_count": self.config.word_count
            },
            dependencies=["modeling"]
        )
        result = await self.orchestrator.execute(task)
        self.results["writing"] = result
        return result.__dict__
  
    async def _run_review(self) -> Dict[str, Any]:
        """æ‰§è¡Œå®¡æ ¸ä¿®æ”¹é˜¶æ®µ"""
        task = TaskDefinition(
            task_id="review",
            name="å®¡æ ¸ä¿®æ”¹",
            description="å®¡æ ¸è®ºæ–‡å¹¶æå‡ºä¿®æ”¹å»ºè®®",
            input_data={
                "draft": self.results.get("writing", {})
            },
            dependencies=["writing"]
        )
        result = await self.orchestrator.execute(task)
        self.results["review"] = result
        return result.__dict__
```

---

## ğŸ“– ä½¿ç”¨ç¤ºä¾‹

### åŸºç¡€ä½¿ç”¨ (`examples/01_simple_chat.py`)

```python
"""
ç¤ºä¾‹1: ç®€å•å¯¹è¯
æ¼”ç¤ºå¦‚ä½•åˆ›å»ºAgentå¹¶è¿›è¡ŒåŸºæœ¬å¯¹è¯
"""
import asyncio
from swagent.core.base_agent import AgentConfig
from swagent.core.message import Message, MessageType
from swagent.agents.planner_agent import PlannerAgent


async def main():
    # 1. åˆ›å»ºAgent
    config = AgentConfig(
        name="å›ºåºŸåŠ©æ‰‹",
        role="å›ºåºŸé¢†åŸŸä¸“å®¶",
        description="ä¸“æ³¨äºå›ºä½“åºŸç‰©ç®¡ç†å’Œå¤„ç†çš„AIåŠ©æ‰‹",
        model="gpt-4",
        temperature=0.7
    )
  
    agent = PlannerAgent(config)
  
    # 2. åˆ›å»ºæ¶ˆæ¯
    user_message = Message(
        sender="user",
        sender_name="ç”¨æˆ·",
        content="è¯·å¸®æˆ‘åˆ†æä¸€ä¸‹åŸå¸‚ç”Ÿæ´»åƒåœ¾ç„šçƒ§å¤„ç†çš„ç¢³æ’æ”¾è®¡ç®—æ–¹æ³•",
        msg_type=MessageType.REQUEST
    )
  
    # 3. è¿è¡ŒAgent
    response = await agent.run(user_message)
  
    # 4. è¾“å‡ºç»“æœ
    print(f"Agentå›å¤:\n{response.content}")
    print(f"\nçŠ¶æ€ä¿¡æ¯: {agent.get_state_info()}")


if __name__ == "__main__":
    asyncio.run(main())
```

### å¤šAgentåä½œ (`examples/04_multi_agent.py`)

```python
"""
ç¤ºä¾‹4: å¤šAgentåä½œ
æ¼”ç¤ºå¤šä¸ªAgentå¦‚ä½•åä½œå®Œæˆå¤æ‚ä»»åŠ¡
"""
import asyncio
from swagent.core.orchestrator import Orchestrator, TaskDefinition, OrchestrationMode
from swagent.agents.planner_agent import PlannerAgent
from swagent.agents.coder_agent import CoderAgent
from swagent.agents.writer_agent import WriterAgent


async def main():
    # 1. åˆ›å»ºç¼–æ’å™¨
    orchestrator = Orchestrator(mode=OrchestrationMode.HIERARCHICAL)
  
    # 2. æ³¨å†ŒAgent
    planner = PlannerAgent()
    # coder = CoderAgent()
    # writer = WriterAgent()
  
    orchestrator.register_agent(planner, is_primary=True)
    # orchestrator.register_agent(coder)
    # orchestrator.register_agent(writer)
  
    # 3. å¯åŠ¨ç¼–æ’å™¨
    await orchestrator.start()
  
    try:
        # 4. åˆ›å»ºä»»åŠ¡
        task = TaskDefinition(
            task_id="task_001",
            name="å›ºåºŸç¢³æ’æ”¾åˆ†ææŠ¥å‘Š",
            description="""
            ä»»åŠ¡è¦æ±‚:
            1. æ”¶é›†æŸåŸå¸‚çš„ç”Ÿæ´»åƒåœ¾å¤„ç†æ•°æ®
            2. è®¡ç®—ä¸åŒå¤„ç†æ–¹å¼çš„ç¢³æ’æ”¾é‡
            3. ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨
            4. æ’°å†™åˆ†ææŠ¥å‘Š
          
            æ•°æ®:
            - åƒåœ¾æ€»é‡: 1000å¨/å¤©
            - ç„šçƒ§æ¯”ä¾‹: 60%
            - å¡«åŸ‹æ¯”ä¾‹: 30%
            - å›æ”¶æ¯”ä¾‹: 10%
            """,
            input_data={
                "city": "ç¤ºä¾‹åŸå¸‚",
                "total_waste": 1000,
                "treatment_ratios": {
                    "incineration": 0.6,
                    "landfill": 0.3,
                    "recycling": 0.1
                }
            }
        )
      
        # 5. æ‰§è¡Œä»»åŠ¡
        result = await orchestrator.execute(task)
      
        # 6. è¾“å‡ºç»“æœ
        print(f"ä»»åŠ¡å®ŒæˆçŠ¶æ€: {'æˆåŠŸ' if result.success else 'å¤±è´¥'}")
        print(f"æ‰§è¡Œæ—¶é—´: {result.execution_time:.2f}ç§’")
        print(f"\nè¾“å‡ºç»“æœ:\n{result.output}")
      
    finally:
        # 7. åœæ­¢ç¼–æ’å™¨
        await orchestrator.stop()


if __name__ == "__main__":
    asyncio.run(main())
```

### ç§‘ç ”å·¥ä½œæµç¤ºä¾‹ (`examples/05_research_workflow.py`)

```python
"""
ç¤ºä¾‹5: ç§‘ç ”å·¥ä½œæµ
æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨ç ”ç©¶å·¥ä½œæµå®Œæˆä¸€ä¸ªå®Œæ•´çš„ç§‘ç ”ä»»åŠ¡
"""
import asyncio
from workflows.research_workflow import ResearchWorkflow, ResearchConfig, ResearchPhase


async def main():
    # 1. é…ç½®ç ”ç©¶ä»»åŠ¡
    config = ResearchConfig(
        topic="åŸå¸‚å›ºä½“åºŸç‰©èµ„æºåŒ–åˆ©ç”¨çš„ç”Ÿå‘½å‘¨æœŸç¢³è¶³è¿¹è¯„ä¼°",
        research_type="å®è¯ç ”ç©¶",
        target_journal="Journal of Cleaner Production",
        word_count=8000,
        include_phases=[
            ResearchPhase.LITERATURE_REVIEW,
            ResearchPhase.DATA_COLLECTION,
            ResearchPhase.DATA_ANALYSIS,
            ResearchPhase.WRITING,
            ResearchPhase.REVIEW
        ],
        data_sources=["Web of Science", "Scopus", "CNKI"],
        keywords=["municipal solid waste", "life cycle assessment", 
                  "carbon footprint", "resource recovery"]
    )
  
    # 2. åˆ›å»ºå·¥ä½œæµ
    workflow = ResearchWorkflow(config)
  
    # 3. è¿è¡Œå®Œæ•´å·¥ä½œæµ
    print("="*50)
    print("å¼€å§‹æ‰§è¡Œç ”ç©¶å·¥ä½œæµ")
    print("="*50)
  
    results = await workflow.run()
  
    # 4. è¾“å‡ºç»“æœ
    print("\n" + "="*50)
    print("ç ”ç©¶å·¥ä½œæµæ‰§è¡Œå®Œæˆ")
    print("="*50)
  
    print(f"\næ‰§è¡ŒçŠ¶æ€: {'æˆåŠŸ' if results['success'] else 'å¤±è´¥'}")
    print(f"æ‰§è¡Œæ—¶é—´: {results['execution_time']:.2f}ç§’")
  
    if results['success']:
        print("\n--- ç ”ç©¶è¾“å‡º ---")
        print(results['output'])


if __name__ == "__main__":
    asyncio.run(main())
```

---

## âš™ï¸ é…ç½®æ–‡ä»¶

### å…¨å±€é…ç½® (`config.yaml`)

```yaml
# SolidWaste-Agent å…¨å±€é…ç½®

# åº”ç”¨ä¿¡æ¯
app:
  name: "SolidWaste-Agent"
  version: "0.1.0"
  description: "å›ºä½“åºŸç‰©é¢†åŸŸæ™ºèƒ½Agentæ¡†æ¶"

# LLMé…ç½®
llm:
  default_provider: "openai"
  providers:
    openai:
      api_key: "${OPENAI_API_KEY}"
      base_url: "https://api.openai.com/v1"
      default_model: "gpt-4"
      timeout: 60
  
    local:
      base_url: "http://localhost:8000"
      default_model: "qwen-7b"
      timeout: 120

# Agenté…ç½®
agents:
  default_temperature: 0.7
  default_max_tokens: 4096
  memory_window_size: 20

  # é¢„å®šä¹‰Agent
  planner:
    name: "è§„åˆ’Agent"
    model: "gpt-4"
    temperature: 0.5

  coder:
    name: "ä»£ç Agent"
    model: "gpt-4"
    temperature: 0.2

  writer:
    name: "å†™ä½œAgent"
    model: "gpt-4"
    temperature: 0.7

  researcher:
    name: "ç ”ç©¶Agent"
    model: "gpt-4"
    temperature: 0.5

# å·¥å…·é…ç½®
tools:
  enabled:
    - code_executor
    - file_handler
    - web_search
    - calculator
    - emission_calculator
    - lca_analyzer

  code_executor:
    timeout: 30
    allowed_languages:
      - python
      - r
    sandbox: true

  web_search:
    provider: "google"
    max_results: 10

# é¢†åŸŸé…ç½®
domain:
  name: "å›ºä½“åºŸç‰©ç®¡ç†"
  knowledge_base_path: "./data/knowledge_base"

  # åºŸç‰©åˆ†ç±»
  waste_categories:
    - municipal_solid_waste
    - industrial_waste
    - hazardous_waste
    - construction_waste
    - agricultural_waste

  # å¤„ç†æ–¹æ³•
  treatment_methods:
    - landfill
    - incineration
    - composting
    - recycling
    - anaerobic_digestion

# æ—¥å¿—é…ç½®
logging:
  level: "INFO"
  format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
  file: "./logs/swagent.log"
  max_size: "10MB"
  backup_count: 5

# å­˜å‚¨é…ç½®
storage:
  type: "local"  # local, redis, mongodb
  local:
    base_path: "./data"
  redis:
    host: "localhost"
    port: 6379
    db: 0
```

---

## ğŸš€ å¼€å‘è·¯çº¿å›¾

### Phase 1: åŸºç¡€æ¡†æ¶ (å½“å‰)
- [x] é¡¹ç›®ç»“æ„è®¾è®¡
- [ ] AgentåŸºç±»å®ç°
- [ ] æ¶ˆæ¯ç³»ç»Ÿå®ç°
- [ ] ä¸Šä¸‹æ–‡ç®¡ç†å®ç°
- [ ] é€šä¿¡åè®®å®ç°
- [ ] ç¼–æ’å™¨å®ç°

### Phase 2: æ ¸å¿ƒAgent
- [ ] PlannerAgentå®Œå–„
- [ ] CoderAgentå®ç°
- [ ] WriterAgentå®ç°
- [ ] ResearcherAgentå®ç°
- [ ] DataAgentå®ç°
- [ ] ReviewerAgentå®ç°

### Phase 3: å·¥å…·ç³»ç»Ÿ
- [ ] ä»£ç æ‰§è¡Œå™¨
- [ ] æ–‡ä»¶å¤„ç†å™¨
- [ ] ç½‘ç»œæœç´¢å·¥å…·
- [ ] æ’æ”¾è®¡ç®—å·¥å…·
- [ ] LCAåˆ†æå·¥å…·
- [ ] å¯è§†åŒ–å·¥å…·

### Phase 4: é¢†åŸŸå¢å¼º
- [ ] å›ºåºŸçŸ¥è¯†åº“æ„å»º
- [ ] ä¸“ä¸šæœ¯è¯­åº“
- [ ] æ ‡å‡†è§„èŒƒåº“
- [ ] é¢†åŸŸæç¤ºè¯ä¼˜åŒ–

### Phase 5: å·¥ä½œæµæ¨¡æ¿
- [ ] ç§‘ç ”å·¥ä½œæµ
- [ ] æŠ¥å‘Šç”Ÿæˆå·¥ä½œæµ
- [ ] æ•°æ®åˆ†æå·¥ä½œæµ
- [ ] ä»£ç å¼€å‘å·¥ä½œæµ

### Phase 6: é«˜çº§ç‰¹æ€§
- [ ] å¤šæ¨¡å‹æ”¯æŒ
- [ ] æŒä¹…åŒ–å­˜å‚¨
- [ ] Web UIç•Œé¢
- [ ] APIæœåŠ¡
- [ ] ç›‘æ§å’Œæ—¥å¿—

---

## ğŸ“ æ³¨æ„äº‹é¡¹

1. **APIå¯†é’¥å®‰å…¨**: ä¸è¦åœ¨ä»£ç ä¸­ç¡¬ç¼–ç APIå¯†é’¥ï¼Œä½¿ç”¨ç¯å¢ƒå˜é‡
2. **å¼‚æ­¥å¤„ç†**: æ¡†æ¶åŸºäºasyncioï¼Œæ³¨æ„æ­£ç¡®ä½¿ç”¨async/await
3. **å†…å­˜ç®¡ç†**: é•¿æ—¶é—´è¿è¡Œæ—¶æ³¨æ„æ¸…ç†å†å²æ¶ˆæ¯å’Œç¼“å­˜
4. **é”™è¯¯å¤„ç†**: æ‰€æœ‰Agentæ‰§è¡Œéƒ½åº”æœ‰é€‚å½“çš„å¼‚å¸¸å¤„ç†
5. **æ‰©å±•å¼€å‘**: æ–°å¢Agentæˆ–å·¥å…·æ—¶éµå¾ªåŸºç±»æ¥å£è§„èŒƒ

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [LangChain Documentation](https://python.langchain.com/)
- [AutoGen Framework](https://microsoft.github.io/autogen/)
- [MetaGPT](https://github.com/geekan/MetaGPT)
- [IPCC Guidelines for National Greenhouse Gas Inventories](https://www.ipcc-nggip.iges.or.jp/)

---

*æ–‡æ¡£ç‰ˆæœ¬: v0.1.0*
*æœ€åæ›´æ–°: 2024å¹´*